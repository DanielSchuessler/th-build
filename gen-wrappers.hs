{-# LANGUAGE FlexibleContexts #-}
import Language.Haskell.Exts
import System.Process
import Control.Exception
import Debug.Trace
import Data.Char
import Data.List
import qualified Data.Map as M
import Data.Map(Map)
import Control.Monad.State
import Control.Applicative
import Data.Maybe

main = do
    bro <- readProcess "ghc" [
                "-dsuppress-module-prefixes",
                "-e",":bro Language.Haskell.TH.Lib"] ""

    putStrLn (process bro)


process bro = 
    case parseModule bro of
         ParseOk mod -> 
            unlines ( 
                "{-# LANGUAGE NoMonomorphismRestriction, FlexibleContexts #-}" :
                "{-# OPTIONS -Wall #-}" :
                "module Language.Haskell.TH.Build.Wrappers where" :
                "import Language.Haskell.TH hiding(Role)" :
                "import Language.Haskell.TH.Lib" :
                "import Language.Haskell.TH.Build.Convertible" :
                "":
                "-- AUTOGENERATED by gen-wrappers.hs!" :
                "" :
                processModule mod
                )
            
         e@(ParseFailed srcLoc _) -> error (unlines (
                                              zipWith (\l i -> show i ++"\t"++l) (lines bro) [1..]
                                              ++
                                              ["Failed to parse :bro output: " ++ show e]
                                            ))


noSrcLoc = error "evaluated noSrcLoc"

processModule (Module _ _ _ _ _ _ decls) = concatMap processDecl decls 


processDecl :: Decl -> [String]
processDecl (TypeSig _ [n] t)
    | arity t == 0 = []
    | otherwise = 
        case n of
            Ident n'
                    -- exclude some functions which only have args of simple types
                | "PrimL" `isSuffixOf` n' || 
                  n' `elem` ["stringL","integerL","rationalL","charL"
                            ,"stringE","tupleT","unboxedTupleT"
                            ,"inlineSpecNoPhase","inlineSpecPhase"
                            -- Deprecated:
                            ,"global"
                            ] -> []
                | otherwise ->
                    mkWrapper t n'

            _ -> trace ("Ignoring operator "++show n) []

processDecl (TypeSig _ _ _) = assert False undefined
processDecl _ = []

mkWrapper :: Type -> String -> [String]
mkWrapper t n =
    let
        n' = n ++ "'"
    in
        [ "-- | Argument-converting wrapper for '"++n++"'." 
        , n' ++ " :: " ++wrapperType t,
          n' ++ " = preconvert"++show (arity t)++" "++n
        ] 

arity (TyFun _ b) = 1 + arity b 
arity _ = 0
    
wrapperType :: Type -> String
wrapperType t = "("++intercalate ", " (prettyPrint <$> cxt)++") => "++prettyPrint rhs
    where
        (cxt,rhs) = runToVar (go t)

        go (TyFun a b) = do
            v <- toVar a
            (cxt',rhs') <- go b
            return ( 
                    (TyApp (TyApp
                                    (TyCon (UnQual (Ident "Convertible"))) 
                                    v)
                                a) : cxt'
                    , TyFun v rhs'
                   )
                   
        go b = return ([], b)
    
runToVar :: State (Map k a) c -> c
runToVar = flip evalState M.empty 

toVar :: (Functor m, MonadState (Map Type Int) m) => Type -> m Type
toVar t =
        do
            i <- fromMaybe 0 <$> gets (M.lookup t)
            modify (M.insert t (i+1))
            return (TyVar (Ident (go t ++ replicate i '\'')))

        
    where
        go (TyList t') = go t' ++ "s" 
        go (TyCon n) = case prettyPrint n of
                        c:cs -> toLower c : cs

        go (TyApp (TyCon (UnQual (Ident "Q"))) t') = go t' ++ "Q" 
        go (TyTuple Boxed [TyCon (UnQual (Ident "Guard")),TyCon (UnQual (Ident "Exp"))]) 
            = "guardedExp"
        go (TyTuple Boxed [TyCon (UnQual (Ident "Strict")),TyCon (UnQual (Ident "Type"))]) 
            = "strictType"
        go (TyApp (TyCon (UnQual (Ident "Maybe"))) (TyCon (UnQual (Ident "ExpQ"))))
            = "maybeExpQ"
        go (TyTuple Boxed [TyCon (UnQual (Ident "Name")),TyCon (UnQual (Ident "Exp"))])
            = "nameExpPair"
        go t' = error ("toVar: don't know what to do with type "++show t')



